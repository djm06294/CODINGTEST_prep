코드리뷰.
https://github.com/codms0201/PPS : issue에 4개 리뷰
https://github.com/codms0201/PPS_S :

A001. 아이들이 필요로 하는 과자수와 가진 과자수를 내림차순으로 정렬하고 인덱스를 돌아가면서 필요로 하는 과자수보다 가진 과자수가 큰 경우 배정시킨다.

A002. 주어진 줄만큼의 파스칼 삼각형이 들어갈 행렬 크기를 동적 할당 해주고, 계산하여 값을 넣어준다.

A003. 마지막 digit부터 carry를 더하고 10으로 나눈 나머지를 저장해준다. carry는 처음에는 1을 더해야하기 때문에 1이고, 이후에는 이전 digit을 10으로 나눈 몫으로 설정해주었다.

A004. 행렬을 입력받고 divisor로 나뉘는 숫자만 또 다른 행렬에 저장한다. 그리고 저장하면서 자신의 앞 인덱스 숫자와 비교해서 작으면 작지 않을 때까지 앞으로 이동한다.

A005. 모든 skill을 int 행렬의 그 알파벳에 해당하는 idx에 배정하고 순서를 나타내는 int를 저장해준다. 주어진 skill tree의 알파벳을 차례대로 skill 행렬에서 찾아보고 그 순서가 뛰지 않았는지 확인해주는 코드이다.

A006. 문자열의 p와 y의 개수를 각각 세어서 둘의 개수를 비교해준다. 

A007. 입력받은 8개의 숫자 중 첫번째의 숫자가 1이면 오름차순인지 확인하고 8이면 내림차순인지 확인한다. 

A008. 모든 성적을 입력받으면서 평균(double)을 구해준다. 그리고 평균을 넘는 모든 점수의 개수를 세고 그 퍼센트를 double로 계산하여 소수점 셋째 자리까지만 출력한다.

A009. 문자열의 길이와 각 char이 숫자인지를 확인하고 답을 출력한다.

A012. 주어진 숫자 n 크기의 bool vector를 정의하고 모든 값을 true로 초기화한다, 그리고 2의 배수부터 모든 존재하는 배수를 false로 만들어준다. 그리고 true의 개수를 반환한다.

A013. 행렬의 모든 숫자를 비교하면서 어떤 두 idx가 다른 숫자 두개가 같으면 다음 숫자를 num에 저장해준다. 마지막에 모든 iteration을 돈 후에 num에 남아있는 숫자가 유일하게 하나만 존재하는 숫자이다.

A014. idx를 0부터 시작해서 다음 인덱스의 저장된 숫자가 현재 인덱스의 저장된 숫자+1이면 인덱스를 계속 +1하다가 그렇지 않으면 string에 넣어준다.

A015. 행렬의 모든 숫자를 더하고 10으로 나눠 검증수를 구한다. (제곱은 왜 안했지?)

A016. 행렬을 내림차순으로 sort해서 가장 큰수와 가장 작은 수를 더해서 limit보다 작거같으면 그 다음 큰 수, 그 다음 작은수로 넘어간다. limit보다 크다면 큰수만 하나 작은수로 만들어주고 큰수는 혼자 보트에 태운다. (어차피 가장 큰수와 탈 수 없는 가장 작은 수가 있다면 작은 수는 바뀔 필요 없이 큰 수만 바꾸면 되네.. 신기)

A017. 6과 9를 뺀 모든 digit의 개수를 센다. 그리고 6과 9는 한번에 세서 2로 나눠준다. 이중 최대 개수를 반환한다.

A018. A와 B를 오름차순으로 정렬한다. 그리고 A와 B의 각 숫자를 곱한 것의 합을 반환한다.

A019. A,B,C를 곱해주고 각 digit을 세어준다.

A020. 각 역에서 타고 내린 사람의 수를 계산해서 기차에 최대의 사람이 있을 떄의 숫자를 반환한다. 

A021. n개의 멀티탭의 플러그 개수를 더해주는데 마지막에는 가장 긴 멀티탭의 플러그의 개수를 빼준다. (왜지?)

A022. 통화를 한 총 시간을 계산하고 영식 요금재로는 30으로 나눈 후 1을 더한 값에 10원을 곱한 값, 민식 요금재는 60으로 나눈 후 1을 더한 값에 15원을 곱한 값이다. 더 작은 요금재를 출력한다.

A023. 주어진 숫자의 각 digit을 다 더해서 한자리 수가 나올 떄까지 반복한다.

A024. 5달러나 10달러를 받는다면 해당하는 돈을 거슬러주고, 20달러를 받앗을 경우에는 10달러가 있다면 10달러로, 아니라면 5달러로 거슬러준다. 5달러가 부족하면 false를 반환한다. (5달러만 체크해도 된다는게 신기하다.)

A025. 주어진 숫자 n이 1이 될때까지 4로 나누는데 나머지가 0이 아닌 경우가 있으면 4의 제곱이 아니다.

A026. 모든 digit을 더하고 본래의 숫자를 나눠서 0이 되는지 확인한다.

A027. 최대 digit의 숫자를 모두 만들어보면서 그 중 최대 값을 찾도록 구현했다. (제대로 이해 못함)

A028. 두 숫자 string의 가장 아래 digit 부터 더해주며 carry를 그 윗 digit으로 전달해준다.

A029. 
A030.
A031. n x m 크기의 초콜렛을 1 x 1의 크기로 쪼개기 위해서는 최소 n x m -1번을 쪼개야하나보다.

A032. 1층부터 각 집에 사는 사람의 수를 계산한다.

A033. 각 참가자의 4개의 점수 총합 중 최대를 구한다.

A034. 42로 나눈 나머지는 0~41이므로 42 크기의 int 행렬을 정의하고 각 수의 나머지 idx에 표시를 한다. 그리고 표시된 요소의 개수를 센다.

A035. 숫자와 기호를 읽고 각 기호에 알맞는 계산을 해준 후 소수점 둘째 자리까지 출력했다.

A045. 각 알파벳을 소문자로 변환해서 숫자를 센다. 그리고 최대 값을 가진 알파벳을 찾는데 중복된 최댓값이 있다면 ?를 출력하도록 했다.

B001. 컴퓨터 개수 n에 대하여 n x n크기의 2차 행렬(graph)를 모두 0으로 초기화해서 만들고 i번째 컴퓨터와 j번째 컴퓨터가 연결되어 있다면 i,j와 j,i의 값을 1로 만들어준다. 그리고 1번째 컴퓨터와 연결된 컴퓨터의 개수를 dfs를 통해 도출해냈다. 나도 dfs를 사용할 때가 언제인지를 판단할 수 있었으면 좋겠다.

B002. 모든 employee에 대한 map을 만든다. 인덱스가 id인 map에 importance 값을 넣어준다. 그리고 회귀 함수를 사용해 주어진 id의 employee의 subordinates 모두의 importance를 더해준다.

B003. root가 null이면 0을 반환, 그리고 root의 left child가 leaf이면 더해서 반환하는 회귀 함수를 사용하여 해결하였다!

B004. 오른쪽과 왼쪽 child가 동일한 값을 갖고 있는지, 그리고 그 child의 오른쪽과 왼쪽의 child가 동일한 값을 갖는지... 이렇게 회귀를 돌아 symmetric한지 판별하는 코드이다. 이해하기 편해서 깔끔하다고 느꼈다.

B005. 이해를 못했다..

B006. 연결관계를 나타내는 graph를 정의해주고 bfs와 dfs를 구현하여 출력하였다. bfs는 연결된 모든 노드를 queue에 넣어주고 하나씩 pop하며 도는 형식인 것 같다.

B007. 행렬의 처음과 마지막을 저장해두고 중간 값을 확인하여 target보다 작으면 오른쪽을 search하고 크면 왼쪽을 search하도록 반복하게 구현했다.

B008. 7번과 비슷하다.

B009. root의 왼쪽 높이와 오른쪽 높이의 차를 구해서 1이하인지 확인하고 밑의 모든 child에 대해서도 이에 해당하는지 확인해준다. 회귀함수를 사용했다.

B010. 회귀적으로 오른쪽 child부터의 높이와 왼쪽 child부터의 높이를 구해주고 두개를 더한 것과 함수 밖 변수인 diameter를 비교해 더 큰 값을 계속 선택해줌으로써 가장 큰 height의 합을 구할 수 있다. (C, C++)

B012. 